'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fields = require('@keystonejs/fields');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var cuid = require('cuid');
var adapterMongoose = require('@keystonejs/adapter-mongoose');
var adapterKnex = require('@keystonejs/adapter-knex');
var adapterPrisma = require('@keystonejs/adapter-prisma');
var mongoose = require('mongoose');
var fetch = require('node-fetch');
var path = require('path');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var cuid__default = /*#__PURE__*/_interopDefault(cuid);
var mongoose__default = /*#__PURE__*/_interopDefault(mongoose);
var fetch__default = /*#__PURE__*/_interopDefault(fetch);
var path__default = /*#__PURE__*/_interopDefault(path);

// https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md#checking-if-a-path-is-populated

mongoose__default['default'].set('objectIdGetter', false);
class LocationGoogleImplementation extends fields.Implementation {
  constructor(_, {
    googleMapsKey
  }) {
    super(...arguments);
    this.graphQLOutputType = 'LocationGoogle';

    if (!googleMapsKey) {
      throw new Error('You must provide a `googleMapsKey` to LocationGoogle Field. To generate a Google Maps API please visit: https://developers.google.com/maps/documentation/javascript/get-api-key');
    }

    this._googleMapsKey = googleMapsKey;
  }

  get _supportsUnique() {
    return false;
  }

  extendAdminMeta(meta) {
    return _objectSpread(_objectSpread({}, meta), {}, {
      googleMapsKey: this._googleMapsKey
    });
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLOutputType}`];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    return [`
      type ${this.graphQLOutputType} {
        id: ID
        googlePlaceID: String
        formattedAddress: String
        lat: Float
        lng: Float
      }
    `];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        }

        return itemValues;
      }
    };
  }

  async resolveInput({
    resolvedData
  }) {
    const placeId = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputId) return inputId`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof placeId === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (placeId === null) {
      // `null` was specifically set, and we should set the field value to null
      // To do that we... return `null`
      return null;
    }

    const response = await fetch__default['default'](`https://maps.googleapis.com/maps/api/geocode/json?place_id=${placeId}&key=${this._googleMapsKey}`).then(r => r.json());

    if (response.results && response.results[0]) {
      const {
        place_id,
        formatted_address
      } = response.results[0];
      const {
        lat,
        lng
      } = response.results[0].geometry.location;
      return {
        id: this.adapter.listAdapter.parentAdapter.name === 'mongoose' ? new mongoose__default['default'].Types.ObjectId() : cuid__default['default'](),
        googlePlaceID: place_id,
        formattedAddress: formatted_address,
        lat: lat,
        lng: lng
      };
    }

    return null;
  }

  gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

  getBackingTypes() {
    const type = `null | {
      id: string;
      googlePlaceID: string;
      formattedAddress: string;
      lat: number;
      lng: number;
      }
    `;
    return {
      [this.path]: {
        optional: true,
        type
      }
    };
  }

}

const CommonLocationInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread(_objectSpread({}, this.equalityConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoLocationGoogleInterface extends CommonLocationInterface(adapterMongoose.MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: {
        id: mongoose__default['default'].Types.ObjectId,
        googlePlaceID: String,
        formattedAddress: String,
        lat: Number,
        lng: Number
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}
class KnexLocationGoogleInterface extends CommonLocationInterface(adapterKnex.KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isIndexed) {
      throw `The LocationGoogle field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}
class PrismaLocationGoogleInterface extends CommonLocationInterface(adapterPrisma.PrismaFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isIndexed) {
      throw `The LocationGoogle field type doesn't support indexes on Prisma. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  getPrismaSchema() {
    return [this._schemaField({
      type: 'Json'
    })];
  }

}

const pkgDir = path__default['default'].dirname(require.resolve('@keystonejs/fields-location-google/package.json'));
const LocationGoogle = {
  type: 'LocationGoogle',
  implementation: LocationGoogleImplementation,
  views: {
    Controller: path__default['default'].join(pkgDir, 'views/Controller'),
    Field: path__default['default'].join(pkgDir, 'views/Field'),
    Cell: path__default['default'].join(pkgDir, 'views/Cell'),
    Filter: fields.Text.views.Filter
  },
  adapters: {
    mongoose: MongoLocationGoogleInterface,
    knex: KnexLocationGoogleInterface,
    prisma: PrismaLocationGoogleInterface
  }
};

exports.LocationGoogle = LocationGoogle;
